## 策略模式 ##
## 1、问题引入  
 在软件开发中常常遇到这样的情况：实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能。如查找、排序等，一种常用的方法是硬编码(Hard Coding)在一个类中，
 如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过if…else…或者case等条件判断语句来进行
 选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为
 困难。如果我们将这些策略包含在客户端，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。  
 关注重点：对象行为封装，行为的选择
 
## 2、策略模式  
解决：将这些算法封装成一个一个的类，任意地替换。  
在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。  
在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。  

## 3、优缺点  
优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。  
缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。  

## 4、使用场景  
1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。   
2、一个系统需要动态地在几种算法中选择一种。   
3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。  

## 5、注意事项  
如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

## TODO：优化
当前的StrategyTest相当于是客户端，现在存在一个问题是每一个具体的决策依然需要我们在客户端指定（如：new StrategyContext(new StrategyAdd())），若策略选择放入context使用一个type  
区分、也需要在context使用if...else来判断选择，可通过其它技术（用到反射）优化